---
title: Snapshot tests
sidebar:
  order: 5
  title: Snapshot tests
---

# Snapshot Testing in Storybook

Snapshot testing is a technique that captures the rendered output of your components and compares it against a stored baseline. While powerful, it's important to choose the right testing approach for your needs.

## When to Use Snapshot Tests

Snapshot tests are best suited for:
- Verifying error handling and error messages
- Testing non-visual component output
- Ensuring DOM structure remains consistent
- Validating component behavior in specific states

For visual testing, we recommend using [visual tests](./visual-testing.mdx) instead, as they're easier to review and maintain.

## Getting Started

### Prerequisites

1. Install the required dependencies:
```bash
npm install --save-dev @storybook/test-runner
```

2. Configure your test environment (Vitest, Jest, or Playwright CT) following the relevant guide:
- [Vitest Setup](../api/portable-stories/portable-stories-vitest.mdx)
- [Jest Setup](../api/portable-stories/portable-stories-jest.mdx)
- [Playwright CT Setup](../api/portable-stories/portable-stories-playwright.mdx)

## Basic Snapshot Testing

Here's a simple example of snapshot testing a Button component:

```tsx
// Button.stories.tsx
import type { Meta, StoryObj } from '@storybook/react';
import { Button } from './Button';

const meta: Meta<typeof Button> = {
  title: 'Components/Button',
  component: Button,
};

export default meta;
type Story = StoryObj<typeof Button>;

export const Primary: Story = {
  args: {
    variant: 'primary',
    children: 'Click me',
  },
};
```

```tsx
// Button.test.tsx
import { composeStories } from '@storybook/react';
import { render } from '@testing-library/react';
import { expect, test } from 'vitest';
import * as stories from './Button.stories';

const { Primary } = composeStories(stories);

test('Button snapshot', () => {
  const { container } = render(<Primary />);
  expect(container).toMatchSnapshot();
});
```

## Advanced Usage

### 1. Testing Error States

Here's how to test error handling in a component:

```tsx
// ErrorBoundary.stories.tsx
export const ThrowsError = {
  args: {
    shouldThrow: true,
  },
  parameters: {
    docs: {
      description: {
        story: 'This story demonstrates error handling',
      },
    },
  },
};

// ErrorBoundary.test.tsx
import { composeStories } from '@storybook/react';
import { expect, test } from 'vitest';
import * as stories from './ErrorBoundary.stories';

const { ThrowsError } = composeStories(stories);

test('ErrorBoundary handles errors', async () => {
  await expect(ThrowsError.run()).rejects.toThrow('Expected error message');
});
```

### 2. Testing Component State Changes

```tsx
// Counter.stories.tsx
export const WithInitialCount = {
  args: {
    initialCount: 5,
  },
};

// Counter.test.tsx
import { composeStories } from '@storybook/react';
import { render, fireEvent } from '@testing-library/react';
import { expect, test } from 'vitest';
import * as stories from './Counter.stories';

const { WithInitialCount } = composeStories(stories);

test('Counter state changes', () => {
  const { container, getByRole } = render(<WithInitialCount />);
  
  // Initial state
  expect(container).toMatchSnapshot('initial-state');
  
  // After clicking increment
  fireEvent.click(getByRole('button', { name: /increment/i }));
  expect(container).toMatchSnapshot('after-increment');
});
```

## Best Practices

1. **Keep Snapshots Focused**
   - Only snapshot the relevant parts of your component
   - Avoid including unnecessary wrapper elements
   - Use data-testid attributes to target specific elements

2. **Maintain Snapshot Quality**
   - Review snapshot changes carefully
   - Update snapshots intentionally, not automatically
   - Keep snapshots up to date with component changes

3. **Organize Your Tests**
   - Group related snapshots together
   - Use descriptive snapshot names
   - Include comments explaining complex snapshots

4. **Handle Dynamic Content**
   - Mock dates and random values
   - Use consistent IDs for dynamic elements
   - Consider using snapshot serializers for complex objects

## Troubleshooting

### Common Issues

1. **Snapshot Mismatches**
   ```diff
   - Expected
   + Received
   ```
   - Review the diff carefully
   - Check for intentional changes
   - Update the snapshot if the change is expected

2. **Flaky Tests**
   - Ensure consistent test environment
   - Mock external dependencies
   - Use deterministic data

3. **Large Snapshots**
   - Focus on specific component parts
   - Use snapshot serializers
   - Consider alternative testing approaches

## Migration from Storyshots

<Callout variant="warning">
Storyshots is deprecated. We recommend migrating to Portable Stories API.
</Callout>

To migrate from Storyshots:
1. Remove Storyshots dependencies
2. Install Portable Stories
3. Update your test files
4. Run your test suite
5. Review and update snapshots

See the [migration guide](../../../release-8-6/docs/writing-tests/snapshot-testing/storyshots-migration-guide.mdx) for detailed steps.

## Additional Resources

- [Visual Testing](./visual-testing.mdx) - For testing component appearance
- [Interaction Testing](./interaction-testing.mdx) - For testing user interactions
- [Accessibility Testing](./accessibility-testing.mdx) - For testing accessibility
- [Test Coverage](./test-coverage.mdx) - For measuring test coverage
- [CI Integration](./in-ci.mdx) - For running tests in CI/CD
- [End-to-End Testing](./integrations/stories-in-end-to-end-tests.mdx) - For full user flow testing
- [Unit Testing](./integrations/stories-in-unit-tests.mdx) - For testing individual functions
- [Test Runner](./integrations/test-runner.mdx) - For automated test execution
