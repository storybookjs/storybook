---
title: 'Play function'
sidebar:
  order: 4
  title: Play function
---

# Play Functions in Storybook

Play functions are a powerful feature in Storybook that let you automate component interactions and test user flows. They run automatically after your story renders, simulating user actions like clicking, typing, and form submissions.

## What are Play Functions?

Play functions are async functions that run after your story renders. They help you:
- Automate component interactions
- Test complex user flows
- Validate form submissions
- Simulate user behavior
- Debug component states

## Basic Usage

Here's a simple example of a play function in a story:

```jsx
// Button.stories.jsx
export const SubmitForm = {
  play: async ({ canvasElement }) => {
    // Get the canvas element
    const canvas = within(canvasElement);
    
    // Find and click the submit button
    const submitButton = canvas.getByRole('button', { name: /submit/i });
    await userEvent.click(submitButton);
    
    // Verify the success message appears
    await expect(canvas.getByText('Form submitted!')).toBeInTheDocument();
  }
};
```

## Common Use Cases

### 1. Form Testing
Here's how to test a registration form:

```jsx
// RegistrationForm.stories.jsx
export const ValidSubmission = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Fill out the form
    await userEvent.type(canvas.getByLabelText(/email/i), 'test@example.com');
    await userEvent.type(canvas.getByLabelText(/password/i), 'password123');
    
    // Submit the form
    await userEvent.click(canvas.getByRole('button', { name: /sign up/i }));
    
    // Verify success state
    await expect(canvas.getByText('Welcome!')).toBeInTheDocument();
  }
};
```

### 2. Modal/Dialog Testing
For components that render outside the main canvas:

```jsx
// Modal.stories.jsx
import { screen } from '@storybook/testing-library';

export const OpenAndClose = {
  play: async () => {
    // Note: We use screen here instead of canvasElement because this is a global modal
    // that renders outside the canvas element. For components within the canvas,
    // use within(canvasElement) instead.
    
    // Open the modal
    await userEvent.click(screen.getByRole('button', { name: /open modal/i }));
    
    // Verify modal content
    await expect(screen.getByRole('dialog')).toBeInTheDocument();
    
    // Close the modal
    await userEvent.click(screen.getByRole('button', { name: /close/i }));
    
    // Verify modal is closed
    await expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
  }
};
```

## Advanced Usage

### Composing Play Functions
You can combine multiple play functions to create complex workflows:

```jsx
// UserProfile.stories.jsx
const login = async ({ canvasElement }) => {
  const canvas = within(canvasElement);
  await userEvent.type(canvas.getByLabelText(/username/i), 'testuser');
  await userEvent.type(canvas.getByLabelText(/password/i), 'password123');
  await userEvent.click(canvas.getByRole('button', { name: /login/i }));
};

const updateProfile = async ({ canvasElement }) => {
  const canvas = within(canvasElement);
  await userEvent.type(canvas.getByLabelText(/name/i), 'New Name');
  await userEvent.click(canvas.getByRole('button', { name: /save/i }));
};

export const CompleteUserFlow = {
  play: async (context) => {
    await login(context);
    await updateProfile(context);
  }
};
```

## Best Practices

1. **Keep it focused**: Each play function should test one specific interaction or flow
2. **Use meaningful names**: Name your play functions to describe what they're testing
3. **Handle async operations**: Always use `async/await` for asynchronous operations
4. **Add assertions**: Verify the expected outcomes of your interactions
5. **Use the Interactions panel**: Debug your play functions using Storybook's Interactions panel

## Troubleshooting

Common issues and solutions:

- **Timing issues**: Use `waitFor` to handle asynchronous updates
- **Missing elements**: Ensure elements are in the DOM before interacting
- **Scope problems**: Use `screen` for elements outside the canvas
- **Async operations**: Always await user interactions and assertions

<Callout variant="info" icon="ðŸ’¡">
  For more details on the available testing utilities, see the [interaction testing documentation](../writing-tests/interaction-testing.mdx).
</Callout>
