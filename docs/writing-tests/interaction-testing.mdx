---
title: 'Interaction tests'
sidebar:
  order: 2
  title: Interaction tests
---

# Interaction Testing in Storybook

Interaction testing allows you to verify that your components behave correctly when users interact with them. By simulating user actions like clicks, typing, and form submissions, you can ensure your components respond appropriately and maintain their expected state.

## Why Interaction Testing?

- **User-Centric**: Tests how real users interact with your components
- **Comprehensive**: Verifies both visual and functional aspects
- **Automated**: Can be run in CI/CD pipelines
- **Debugging**: Built-in tools for debugging interactions
- **Integration**: Works seamlessly with other testing methods

## Getting Started

### 1. Basic Interaction Test

Here's a simple example of testing a button click:

```tsx
// Button.stories.tsx
import type { Meta, StoryObj } from '@storybook/react';
import { Button } from './Button';
import { within, userEvent } from '@storybook/testing-library';
import { expect } from '@storybook/test';

const meta: Meta<typeof Button> = {
  title: 'Components/Button',
  component: Button,
};

export default meta;
type Story = StoryObj<typeof Button>;

export const Clickable: Story = {
  args: {
    label: 'Click me',
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);
    
    // Find the button
    const button = canvas.getByRole('button', { name: 'Click me' });
    
    // Click the button
    await userEvent.click(button);
    
    // Verify the button was clicked
    await expect(button).toHaveAttribute('data-clicked', 'true');
  },
};
```

### 2. Form Interaction Test

Testing form interactions is a common use case:

```tsx
// LoginForm.stories.tsx
export const SubmitForm: Story = {
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);
    
    await step('Fill out the form', async () => {
      // Find form elements
      const emailInput = canvas.getByLabelText('Email');
      const passwordInput = canvas.getByLabelText('Password');
      const submitButton = canvas.getByRole('button', { name: 'Submit' });
      
      // Fill in the form
      await userEvent.type(emailInput, 'test@example.com');
      await userEvent.type(passwordInput, 'password123');
      
      // Submit the form
      await userEvent.click(submitButton);
    });
    
    await step('Verify submission', async () => {
      // Check for success message
      const successMessage = await canvas.findByText('Login successful');
      await expect(successMessage).toBeVisible();
    });
  },
};
```

## Advanced Testing Techniques

### 1. Testing Complex Interactions

```tsx
// Dropdown.stories.tsx
export const SelectOption: Story = {
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);
    
    await step('Open dropdown', async () => {
      const trigger = canvas.getByRole('button', { name: 'Select option' });
      await userEvent.click(trigger);
      
      // Verify dropdown is open
      const dropdown = await canvas.findByRole('listbox');
      await expect(dropdown).toBeVisible();
    });
    
    await step('Select option', async () => {
      const option = canvas.getByRole('option', { name: 'Option 1' });
      await userEvent.click(option);
      
      // Verify selection
      const selectedValue = canvas.getByText('Option 1');
      await expect(selectedValue).toBeVisible();
    });
  },
};
```

### 2. Testing Keyboard Navigation

```tsx
// Menu.stories.tsx
export const KeyboardNavigation: Story = {
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);
    
    await step('Navigate with keyboard', async () => {
      // Focus the menu
      const menu = canvas.getByRole('menu');
      menu.focus();
      
      // Navigate down
      await userEvent.keyboard('{ArrowDown}');
      const firstItem = canvas.getByRole('menuitem', { name: 'Item 1' });
      await expect(firstItem).toHaveFocus();
      
      // Navigate to next item
      await userEvent.keyboard('{ArrowDown}');
      const secondItem = canvas.getByRole('menuitem', { name: 'Item 2' });
      await expect(secondItem).toHaveFocus();
    });
  },
};
```

## Best Practices

1. **Use Semantic Queries**
   - Prefer `getByRole` over `getByTestId`
   - Use accessible names and labels
   - Follow Testing Library's query priority

2. **Group Related Actions**
   - Use the `step` function to organize tests
   - Give clear, descriptive step names
   - Keep steps focused and atomic

3. **Handle Asynchronous Operations**
   - Use `findBy` queries for async elements
   - Wait for animations to complete
   - Handle loading states appropriately

4. **Maintain Test Independence**
   - Reset state between tests
   - Use `beforeEach` for common setup
   - Clean up after tests

## Common Testing Patterns

### 1. Testing Modal/Dialog Interactions

```tsx
// Modal.stories.tsx
export const OpenAndClose: Story = {
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);
    
    await step('Open modal', async () => {
      const openButton = canvas.getByRole('button', { name: 'Open Modal' });
      await userEvent.click(openButton);
      
      const modal = await canvas.findByRole('dialog');
      await expect(modal).toBeVisible();
    });
    
    await step('Close modal', async () => {
      const closeButton = canvas.getByRole('button', { name: 'Close' });
      await userEvent.click(closeButton);
      
      const modal = canvas.queryByRole('dialog');
      await expect(modal).not.toBeInTheDocument();
    });
  },
};
```

### 2. Testing Form Validation

```tsx
// Form.stories.tsx
export const Validation: Story = {
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);
    
    await step('Submit empty form', async () => {
      const submitButton = canvas.getByRole('button', { name: 'Submit' });
      await userEvent.click(submitButton);
      
      // Check for validation messages
      const errorMessage = await canvas.findByText('This field is required');
      await expect(errorMessage).toBeVisible();
    });
    
    await step('Submit valid form', async () => {
      const input = canvas.getByLabelText('Name');
      await userEvent.type(input, 'John Doe');
      
      const submitButton = canvas.getByRole('button', { name: 'Submit' });
      await userEvent.click(submitButton);
      
      // Verify success
      const successMessage = await canvas.findByText('Form submitted');
      await expect(successMessage).toBeVisible();
    });
  },
};
```

## Troubleshooting

### 1. Common Issues

<CodeSnippets path="before-all-in-preview.md" />
- **Timing Issues**: Use `findBy` queries and appropriate delays
- **Missing Elements**: Verify element roles and accessibility
- **State Management**: Reset state between tests
- **Async Operations**: Handle loading states and animations

### 2. Test Runner vs Vitest Addon

Note that the test runner has been superseded by the Vitest addon, which offers the same functionality for running interaction tests in CI/CD pipelines. We recommend using the Vitest addon for new projects and migrating existing projects when possible.

## Additional Resources

- [Testing Library Documentation](https://testing-library.com/docs/)
- [User Event Documentation](https://testing-library.com/docs/user-event/intro)
- [Jest DOM Matchers](https://github.com/testing-library/jest-dom#custom-matchers)
- [Storybook Testing Guide](https://storybook.js.org/docs/writing-tests/introduction)

<Callout variant="info">
Remember: Interaction tests should focus on user behavior, not implementation details. Write tests that verify what users can do with your components, not how they're implemented.
</Callout>
