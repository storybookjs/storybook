---
title: 'TypeScript'
sidebar:
  order: 4
  title: Typescript
---

Storybook provides an integrated [TypeScript](https://www.typescriptlang.org/) experience, including zero-configuration setup and built-in types for APIs, addons, and stories.

## Configure Storybook with TypeScript

Storybook's configuration file (i.e., `main.ts`) is defined as an ESM module written in TypeScript, providing you with the baseline configuration to support your existing framework while enabling you stricter type-checking and autocompletion in your editor. Below is an abridged configuration file.

{/* prettier-ignore-start */}

<CodeSnippets path="main-config-typical.md" />

{/* prettier-ignore-end */}

See the [main configuration API reference](../../api/main-config/main-config.mdx) for more details and additional properties.

<Callout variant="info" icon="ðŸ’¡">
  See the Vite builder [TypeScript documentation](https://github.com/storybookjs/builder-vite#typescript) if using `@storybook/builder-vite`.
</Callout>

### Extending the default configuration

<IfRenderer renderer={['angular', 'vue', 'web-components', 'ember', 'html', 'svelte', 'preact', 'qwik', 'solid' ]}>
  Out of the box, Storybook is built to work with a wide range of third-party libraries, enabling you to safely access and document metadata (e.g., props, inputs) from your components without any additional configuration. Since Storybook supports multiple frameworks, it also includes a set of third-party packages to support each framework (e.g., `ts-loader`, `vue-docgen-api` for Vue). If you need to customize the default configuration for a specific use case scenario, you can adjust your Storybook configuration file and provide the required options. Listed below are the available options and examples of how to use them.

  | Option         | Description                                                                                                                                                                                                    |
  | -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | `check`        | Available for Webpack-based projects.<br />Enables type checking within Storybook<br />`typescript: { check: true },`                                                                                          |
  | `checkOptions` | Requires the `check` option to be enabled.<br />Configures the [`fork-ts-checker-webpack-plugin`](https://github.com/TypeStrong/fork-ts-checker-webpack-plugin) plugin<br />`typescript: { checkOptions:{},},` |
  | `skipCompiler` | Disables parsing Typescript files through the compiler<br />`typescript: { skipCompiler:false,},`                                                                                                              |
</IfRenderer>

<IfRenderer renderer="react">
  Out of the box, Storybook is built to work with a wide range of third-party libraries, enabling you to safely access and document metadata (e.g., props) for your components without any additional configuration. It relies on [`react-docgen`](https://github.com/reactjs/react-docgen), a fast and highly customizable parser to process TypeScript files to infer the component's metadata and generate types automatically for improved performance and type safety. If you need to customize the default configuration for a specific use case scenario, you can adjust your Storybook configuration file and provide the required options. Listed below are the available options and examples of how to use them.

  | Option                         | Description                                                                                                                                                                                                                                 |
  | ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | `check`                        | Available for Webpack-based projects.<br />Enables type checking within Storybook<br />`typescript: { check: true },`                                                                                                                       |
  | `checkOptions`                 | Requires the `check` option to be enabled.<br />Configures the [`fork-ts-checker-webpack-plugin`](https://github.com/TypeStrong/fork-ts-checker-webpack-plugin) plugin<br />`typescript: { checkOptions: {},},`                             |
  | `reactDocgen`                  | Configures the TypeScript parser used by Storybook.<br />Available options: `react-docgen` (default), `react-docgen-typescript`,` false`<br /> `typescript: { reactDocgen: 'react-docgen'},`                                                |
  | `reactDocgenTypescriptOptions` | Requires the `reactDocgen`option to be `react-docgen-typescript`.<br /> Configures the `react-docgen-typescript-plugin` plugin per builder<br />`typescript: { reactDocgen: 'react-docgen-typescript', reactDocgenTypescriptOptions: {},},` |
  | `skipCompiler`                 | Disables parsing Typescript files through the compiler<br />`typescript: { skipCompiler:false,},`                                                                                                                                           |
</IfRenderer>

{/* prettier-ignore-start */}

<CodeSnippets path="storybook-main-extend-ts-config.md" />

{/* prettier-ignore-end */}

<Callout>
  Additional options are available for the `typescript` configuration option. See the [`config.typescript` API reference](../../api/main-config/main-config-typescript.mdx) for more information.
</Callout>

## Write stories with TypeScript

Storybook provides zero-config TypeScript support, allowing you to write stories using this language without additional configuration. You can use this format for improved type safety and code completion. For example, if you're testing a `Button` component, you could do the following in your story file:

{/* prettier-ignore-start */}

<CodeSnippets path="button-story-baseline.md" />

{/* prettier-ignore-end */}

The example above uses the power of TypeScript in combination with the exported generic types (`Meta` and `StoryObj`) to tell Storybook how to infer the component's metadata and the type of the component's inputs (e.g., props). This can greatly improve the developer experience by letting your IDE show you what properties are injected by Storybook.

### TypeScript 4.9 support

Assuming that you're working on a project that uses TypeScript 4.9+, you can update your component stories to use the new [`satisfies`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html) operator to ensure stricter type checking for your component stories. For example:

{/* prettier-ignore-start */}

<CodeSnippets path="button-story-baseline-with-satisfies.md" />

{/* prettier-ignore-end */}

Now, when you define a story or update an existing one, you'll automatically get notified that you're missing a required [`arg`](../../writing-stories/args.mdx). However, you're not limited to using the `satisfies` operator at the component level. If you need, you can also use it at the story level. For example:

{/* prettier-ignore-start */}

<CodeSnippets path="button-story-baseline-with-satisfies-story-level.md" />

{/* prettier-ignore-end */}

## Generating TypeScript declaration files

If you're building a library and have `"declaration": true` in your tsconfig, you may encounter errors like these when your stories are included in the build:

```
TS2742: The inferred type of 'Foo' cannot be named without a reference to
'some-lib/node_modules/some-internal-module'. This is likely not portable.
A type annotation is necessary.

TS4023: Exported variable 'Foo' has or is using name 'Bar' from external module
"some-lib/internal" but cannot be named.
```

This happens because Storybook's types sometimes reference internal modules that TypeScript cannot include in portable declaration files. We've fixed many of these issues over the years by re-exporting internal types, but new ones keep appearing as the API evolvesâ€”and we don't want to expose all our internal types.

With CSF3, this can sometimes be worked around by explicitly importing the missing types. However, we recommend typing meta with `satisfies Meta<...>` for better type safety, and `satisfies` doesn't provide an explicit type annotation. With [CSF factories](../../api/csf/csf-next.mdx), explicit type annotations aren't feasible since the API is designed around type inference. If you use the [`isolatedDeclarations`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#isolated-declarations) option, the problem becomes unavoidable since it requires explicit annotations for all exportsâ€”which neither `satisfies` nor CSF factories provide.

### Solution

We recommend excluding story files from your declaration build. Stories are development-time assetsâ€”consumers of your package interact with your components, not your stories, so they don't need story type definitions. Your IDE and type checking continue to work normally.

There are two ways to achieve this:

### Option 1: Separate build config

The simpler approach is to set `declaration: false` in your base config and create a separate `tsconfig.build.json` for generating declarations:

```diff
// tsconfig.json
{
  "compilerOptions": {
+   "declaration": false
  }
}
```

```json
// tsconfig.build.json (new file)
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "declaration": true
  },
  "exclude": ["**/*.stories.*", "**/*.story.*", ".storybook/**"]
}
```

Then update your build script to use the build config:

```bash
tsc -p tsconfig.build.json
```

### Option 2: Project references

Using [TypeScript project references](https://www.typescriptlang.org/docs/handbook/project-references.html) separates your app code from Storybook files. This is the approach used by `create-vite` and other modern tooling. The advantage over Option 1 is that your IDE will also show declaration build errors. The downside is that project references are more complex to set up.

```json
// tsconfig.json
{
  "files": [],
  "references": [
    { "path": "./tsconfig.build.json" },
    { "path": "./tsconfig.storybook.json" }
  ]
}

// tsconfig.build.json - your app code, generates declarations
{
  "compilerOptions": {
    "composite": true,
    "declaration": true
    // ...other options
  },
  "include": ["src"],
  "exclude": ["**/*.stories.*", "**/*.story.*"]
}

// tsconfig.storybook.json - stories and Storybook config
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "composite": true,
    "declaration": false
  },
  "include": ["src/**/*.stories.*", ".storybook/**"],
  "references": [
    { "path": "./tsconfig.build.json" }
  ]
}
```

## Troubleshooting

### The `satisfies` operator is not working as expected

Out of the box, Storybook supports the `satisfies` operator for almost every framework already using TypeScript version 4.9 or higher. However, due to the constraints of the Angular and Web Components framework, you might run into issues when applying this operator for additional type safety. This is primarily due to how both frameworks are currently implemented, making it almost impossible for Storybook to determine if the component property is required. If you encounter this issue, please open up a support request on [GitHub Discussions](https://github.com/storybookjs/storybook/discussions/new?category=help).

<IfRenderer renderer={[ 'vue', 'svelte' ]}>
  ### The TypeScript auto-completion is not working on my editor

  If you're using Vue single file components and TypeScript, you can add the official [Vue](https://marketplace.visualstudio.com/items?itemName=Vue.volar) extension for editor support, additional type safety and auto-completion. Nevertheless, if you're working with Svelte, you can add the [Svelte for VSCode extension](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode) for similar benefits.
</IfRenderer>

<IfRenderer renderer="react">
  ### Storybook doesn't create the required types for external packages

  If your project relies on a third-party library and the expected types are not being generated, preventing you from accurately documenting your components, you can adjust the `reactDocgen` configuration option in your Storybook configuration file to use `react-docgen-typescript` instead and include the required options. For example:

  {/* prettier-ignore-start */}

  <CodeSnippets path="storybook-main-prop-filter.md" />

  {/* prettier-ignore-end */}

  ### The types are not being generated for my component

  If you're working with a React project, type inference is automatically enabled for your components using the `react-docgen` library for improved build times and type safety. However, you may run into a situation where some options may not work as expected (e.g., [`Enums`](https://www.typescriptlang.org/docs/handbook/enums.html), React's [`forwardRef`](https://react.dev/reference/react/forwardRef)). This is primarily due to how the `react-docgen` package is implemented, making it difficult for Storybook to infer the component's metadata and generate types automatically. To solve this, you can update the `typescript` configuration option in your Storybook configuration file to use `react-docgen-typescript` instead. For example:

  {/* prettier-ignore-start */}

  <CodeSnippets path="storybook-main-react-docgen-typescript.md" />

  {/* prettier-ignore-end */}

  If you're still encountering issues, we recommend reaching out to the community using the default communication channels (e.g., [GitHub discussions](https://github.com/storybookjs/storybook/discussions/new?category=help)).
</IfRenderer>
