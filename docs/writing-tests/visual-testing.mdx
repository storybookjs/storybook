---
title: Visual tests
hideRendererSelector: true
sidebar:
  order: 4
  title: Visual tests
---

# Visual Testing in Storybook

Visual testing is a powerful way to ensure your UI components maintain their intended appearance across changes. By capturing and comparing visual snapshots of your components, you can catch unintended visual regressions before they reach production.

## Why Visual Testing?

- **Efficiency**: Test multiple aspects of your components without writing test code
- **Accuracy**: Compare actual rendered pixels, not just markup
- **Coverage**: Automatically test every story in your Storybook
- **Cross-browser**: Test across different browsers and viewports
- **CI Integration**: Automate visual testing in your development workflow

## Getting Started

### 1. Install the Visual Testing Addon

```bash
npx storybook add @chromatic-com/storybook
```

This installs Chromatic, a cloud service built by the Storybook team for visual testing.

### 2. Configure Your Project

Create a `chromatic.config.json` file in your project root:

```json
{
  "projectId": "your-project-id",
  "buildScriptName": "build-storybook",
  "debug": false,
  "zip": true
}
```

### 3. Set Up CI Integration

Add to your GitHub Actions workflow:

```yaml
# .github/workflows/visual-tests.yml
name: Visual Tests
on: [push, pull_request]
jobs:
  chromatic:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - name: Publish to Chromatic
        uses: chromaui/action@v1
        with:
          projectToken: ${{ secrets.CHROMATIC_PROJECT_TOKEN }}
```

## Writing Visual Tests

### 1. Basic Component Example

```tsx
// Button.stories.tsx
import type { Meta, StoryObj } from '@storybook/react';
import { Button } from './Button';

const meta: Meta<typeof Button> = {
  title: 'Components/Button',
  component: Button,
  parameters: {
    // Configure viewport for responsive testing
    chromatic: { viewports: [320, 768, 1024] },
  },
};

export default meta;
type Story = StoryObj<typeof Button>;

export const Primary: Story = {
  args: {
    variant: 'primary',
    children: 'Click me',
  },
};

export const Secondary: Story = {
  args: {
    variant: 'secondary',
    children: 'Click me',
  },
};
```

### 2. Complex Component Example

```tsx
// Modal.stories.tsx
export const WithOverlay: Story = {
  args: {
    isOpen: true,
    title: 'Example Modal',
  },
  parameters: {
    chromatic: {
      // Configure specific viewport
      viewport: { width: 1024, height: 768 },
      // Disable animations for consistent snapshots
      disableAnimations: true,
      // Configure delay for async content
      delay: 1000,
    },
  },
};
```

## Advanced Configuration

### 1. Viewport Configuration

```ts
// .storybook/preview.ts
const preview: Preview = {
  parameters: {
    chromatic: {
      // Test across multiple viewports
      viewports: [
        { width: 320, height: 568 },  // Mobile
        { width: 768, height: 1024 }, // Tablet
        { width: 1024, height: 768 }, // Desktop
      ],
    },
  },
};
```

### 2. Animation Handling

```tsx
// AnimatedComponent.stories.tsx
export const WithAnimation: Story = {
  parameters: {
    chromatic: {
      // Disable animations for consistent snapshots
      disableAnimations: true,
      // Or capture after animation completes
      delay: 500,
    },
  },
};
```

## Testing Workflow

### 1. Development Workflow

1. **Run Tests Locally**
   - Use the Visual Tests panel in Storybook
   - Click "Catch a UI change" to run tests
   - Review changes in the diff viewer

2. **Review Changes**
   - Accept intentional changes as baselines
   - Fix unintended changes
   - Rerun tests to verify fixes

3. **Commit and Push**
   - Changes are synced to Chromatic
   - CI runs visual tests automatically
   - PR checks show test status

### 2. CI Integration

```yaml
# .github/workflows/chromatic.yml
name: Chromatic
on: [push, pull_request]
jobs:
  chromatic:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - name: Publish to Chromatic
        uses: chromaui/action@v1
        with:
          projectToken: ${{ secrets.CHROMATIC_PROJECT_TOKEN }}
          exitZeroOnChanges: true
```

## Best Practices

1. **Viewport Management**
   - Test across multiple viewports
   - Include mobile and desktop sizes
   - Consider device-specific layouts

2. **Animation Handling**
   - Disable animations for consistent snapshots
   - Use delays for async content
   - Test animation states separately

3. **Component Organization**
   - Group related stories
   - Use meaningful story names
   - Document visual test requirements

4. **CI Strategy**
   - Run tests on every PR
   - Require visual test approval
   - Automate baseline updates

## Common Issues and Solutions

### 1. Flaky Tests

```tsx
// Handle flaky tests
export const AsyncContent: Story = {
  parameters: {
    chromatic: {
      // Wait for content to load
      delay: 1000,
      // Retry failed tests
      retries: 3,
    },
  },
};
```

### 2. Dynamic Content

```tsx
// Handle dynamic content
export const WithDate: Story = {
  parameters: {
    chromatic: {
      // Mock date for consistent snapshots
      date: '2024-01-01',
    },
  },
};
```

## Additional Resources

- [Chromatic Documentation](https://www.chromatic.com/docs/)
- [Visual Testing Best Practices](https://www.chromatic.com/docs/best-practices)
- [CI Integration Guide](https://www.chromatic.com/docs/ci)
- [Viewport Configuration](https://www.chromatic.com/docs/viewport)

<Callout variant="info">
Remember: Visual testing is not just about catching bugsâ€”it's about maintaining a consistent and polished user interface across your application.
</Callout>
